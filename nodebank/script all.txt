# dict_get_node.py
def dict_get_node(DictObj, Key):
    if DictObj is None:
        return None
    return DictObj.get(Key)


# dict_set_node.py
def dict_set_node(DictObj, Key, Value):
    if DictObj is None:
        DictObj = {}
    DictObj[Key] = Value
    return DictObj


# input_node.py
def io_input_node(Value):
    return Value


# print.py
from executor.utils.node_logger import log_print

def io_print_node(inputs):
    log_print(f"Printing: {inputs}")
    print(inputs)


# list_append_node.py
def list_append_node(List, Item):
    if List is None:
        List = []
    List.append(Item)
    return List


# list_length_node.py
def list_length_node(List):
    if List is None:
        ListLegnth = 0
    ListLegnth = len(List)
    return ListLegnth


    # logic_equal_node.py
def logic_equal_node(Inputs1, Inputs2):
    Bool = Inputs1 == Inputs2
    return Bool

    # logic_greater_node.py
def logic_greater_node(Inputs1, Inputs2):
    Bool = Inputs1 > Inputs2
    return Bool

    # logic_less_node.py
def logic_less_node(Inputs1, Inputs2):
    Bool = Inputs1 < Inputs2
    return Bool

    # logic_not_equal_node.py
def logic_not_equal_node(Inputs1, Inputs2):
    Bool = Inputs1 != Inputs2
    return Bool


    # loop_for_node.py
def loop_for_node(Start, End, Step):
    if Start is None:
        Start = 0
    if End is None:
        End = 1
    if Step is None or Step == 0:
        Step = 1
    Loop = list(range(Start, End, Step))
    return Loop


    # math_add_node.py
from executor.utils.node_logger import log_print

def math_add_node(Inputs1, Inputs2):
    # Log the operation
    log_print(f"Adding {Inputs1} + {Inputs2}")
    
    if Inputs1 is None:
        Inputs1 = 0
    if Inputs2 is None:
        Inputs2 = 0
    
    Math = Inputs1 + Inputs2
    
    # Log the result
    log_print(f"Result: {Math}")
    
    return Math


# math_divide_node.py
import sys

def math_divide_node(Inputs1, Inputs2):
    if Inputs1 is None:
        Inputs1 = 0
    if Inputs2 in (None, 0):
         sys.exit("Cannot divide by zero!")
    Math = Inputs1 / Inputs2
    return Math

    # math_multiply_node.py
def math_multiply_node(Inputs1, Inputs2):
    if Inputs1 is None:
        Inputs1 = 1
    if Inputs2 is None:
        Inputs2 = 1
    Math = Inputs1 * Inputs2
    return Math


    # math_subtract_node.py
def math_subtract_node(Inputs1, Inputs2):
    if Inputs1 is None:
        Inputs1 = 0
    if Inputs2 is None:
        Inputs2 = 0
    Math = Inputs1 - Inputs2
    return Math


    # random_float_node.py
import random
def random_float_node(Min, Max):
    if Min is None:
        Min = 0.0
    if Max is None:
        Max = 1.0
    Random = random.uniform(Min, Max)
    return  Random

    # random_int_node.py
import random
from executor.utils.node_logger import log_print

def random_int_node(Min, Max):
    if Min is None:
        Min = 0
    if Max is None:
        Max = 100
    
    log_print(f"Generating random integer between {Min} and {Max}")
    
    Random = random.randint(Min, Max)
    
    log_print(f"Generated: {Random}")
    
    return Random


# string_concat_node.py
def string_concat_node(Str1, Str2):
    if Str1 is None:
        Str1 = ""
    if Str2 is None:
        Str2 = ""
    String = str(Str1) + str(Str2)
    return String




    # string_lower_node.py
def string_lower_node(Value):
    if Value is None:
        Value = ""
    String = str(Value).lower()
    return String



    # string_upper_node.py
def string_upper_node(Value):
    if Value is None:
        Value = ""
    String = str(Value).upper()
    return String